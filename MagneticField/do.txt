///////////////////////////////////////////////
/// \brief A method that creates a canvas where tracks traversing the magnetic volume
/// are drawm together with their corresponding field intensity profile along the Z-axis. 
/// The tracks are passed as an argument instead.
///
TCanvas* TRestAxionMagneticField::DrawTracks(const std::vector<TVector3>& startPoints, const std::vector<TVector3>& endPoints, Int_t divisions, Bool_t savePDF, Int_t volId) {
    if (fCanvas != nullptr) {
        delete fCanvas;
        fCanvas = nullptr;
    }
    fCanvas = new TCanvas("fCanvas", "", 1600, 600);

    TPad* pad1 = new TPad("pad1", "This is pad1", 0.01, 0.02, 0.99, 0.97);
    TLegend* legend = new TLegend(0.1, 0.7, 0.3, 0.9); 
    pad1->Divide(2, 1);
    pad1->Draw();

    pad1->cd(1);

    Double_t genSizeY = fBoundMax[volId].Y() * 2.;
    Double_t genPositionZ = fPositions[volId][2] - fBoundMax[volId].Z() - 2000;
    Double_t finalPositionZ = fPositions[volId][2] + fBoundMax[volId].Z() + 2000;

    // Draw bounding box
    TGraph* bBox = new TGraph();
    bBox->SetPoint(0, fPositions[volId][2] - fBoundMax[volId].Z(), fPositions[volId][1] - fBoundMax[volId].Y());
    bBox->SetPoint(1, fPositions[volId][2] - fBoundMax[volId].Z(), fPositions[volId][1] + fBoundMax[volId].Y());
    bBox->SetPoint(2, fPositions[volId][2] + fBoundMax[volId].Z(), fPositions[volId][1] + fBoundMax[volId].Y());
    bBox->SetPoint(3, fPositions[volId][2] + fBoundMax[volId].Z(), fPositions[volId][1] - fBoundMax[volId].Y());
    bBox->SetPoint(4, fPositions[volId][2] - fBoundMax[volId].Z(), fPositions[volId][1] - fBoundMax[volId].Y());
    
    bBox->SetLineColor(kBlack);
    bBox->SetLineWidth(2);
    bBox->GetXaxis()->SetLimits(genPositionZ, finalPositionZ);
    bBox->GetHistogram()->SetMaximum(genSizeY + 100);
    bBox->GetHistogram()->SetMinimum(-genSizeY - 100);
    bBox->GetXaxis()->SetTitle("Z [mm]");
    bBox->GetXaxis()->SetTitleSize(0.03);
    bBox->GetXaxis()->SetLabelSize(0.03);
    bBox->GetYaxis()->SetTitle("Y [mm]");
    bBox->GetYaxis()->SetTitleOffset(1.3);
    bBox->GetYaxis()->SetTitleSize(0.03);
    bBox->GetYaxis()->SetLabelSize(0.03);
    bBox->SetLineWidth(2);
    bBox->Draw("AL");
    
    std::vector<Color_t> colors = {kYellow+1, kYellow-5, kGreen+1, kGreen-1, kCyan+1, kBlue+1, kMagenta+1, kRed+1};
    Int_t n = 0;
    for (size_t i = 0; i < startPoints.size(); ++i) {
        TVector3 startPosition = startPoints[i];
        TVector3 endPosition = endPoints[i];
        TVector3 direction = (endPosition - startPosition).Unit();

        std::vector<TVector3> trackBounds = this->GetFieldBoundaries(startPosition, direction);

        TGraph* grB = new TGraph();
        grB->SetPoint(0, trackBounds[0].Z(), trackBounds[0].Y());
        grB->SetPoint(1, trackBounds[1].Z(), trackBounds[1].Y());

        RESTDebug << "Initial" << RESTendl;
        RESTDebug << "-------" << RESTendl;
        if (GetVerboseLevel() >= TRestStringOutput::REST_Verbose_Level::REST_Debug) startPosition.Print();

        RESTDebug << RESTendl;
        RESTDebug << "Start moving along" << RESTendl;
        RESTDebug << "++++++++++++++++++" << RESTendl;

        TGraph* fieldGr = new TGraph();
        Double_t posZ = fPositions[volId][2] - fBoundMax[volId].Z() - 10;
        Double_t delta = fBoundMax[volId][2] * 2. / divisions;

        Double_t field = this->GetTransversalComponent(startPosition, direction);
        fieldGr->SetPoint(fieldGr->GetN(), posZ, field);

        while (posZ <= fPositions[volId][2] + fBoundMax[volId].Z()) {
            TVector3 posAlongAxis = TVector3(fPositions[volId][0], fPositions[volId][1], posZ);

            startPosition = MoveToPlane(startPosition, direction, TVector3(0, 0, 1), posAlongAxis);
            Double_t field = this->GetTransversalComponent(startPosition, direction);

            fieldGr->SetPoint(fieldGr->GetN(), posZ, field);

            posZ += delta;
        }

        TVector3 posAlongAxis = TVector3(fPositions[volId][0], fPositions[volId][1], posZ + 10);
        startPosition = MoveToPlane(startPosition, direction, TVector3(0, 0, 1), posAlongAxis);

        Double_t field2 = this->GetTransversalComponent(startPosition, direction);
        fieldGr->SetPoint(fieldGr->GetN(), posZ, field2);

        pad1->cd(2);
        fieldGr->SetLineWidth(2);
        fieldGr->SetLineColor(colors[i]);
        fieldGr->GetXaxis()->SetLimits(genPositionZ - 500, finalPositionZ + 500);
        fieldGr->GetHistogram()->SetMaximum(2.5);
        fieldGr->GetHistogram()->SetMinimum(0);
        fieldGr->GetXaxis()->SetTitle("Z [mm]");
        fieldGr->GetXaxis()->SetTitleSize(0.03);
        fieldGr->GetXaxis()->SetLabelSize(0.03);
        fieldGr->GetYaxis()->SetTitle("B [T]");
        fieldGr->GetYaxis()->SetTitleOffset(1.3);
        fieldGr->GetYaxis()->SetTitleSize(0.03);
        fieldGr->GetYaxis()->SetLabelSize(0.03);
        if (i == 0)
            fieldGr->Draw("AL");
        else
            fieldGr->Draw("L");

        // Add legend entries for each track profile
        std::string legendEntry = Form("Track %zu", i + 1); 
        legend->AddEntry(fieldGr, legendEntry.c_str(), "l");

        pad1->cd(1);

        TGraph* gr = new TGraph();
        gr->SetPoint(0, startPosition.Z(), startPosition.Y());
        gr->SetPoint(1, endPosition.Z(), endPosition.Y());

        gr->SetLineWidth(1.5);
        gr->Draw("L");
        grB->SetLineColor(38 + n);
        n++;
        grB->SetLineWidth(3);
        grB->Draw("L");

    }

    bBox->Draw("L");

    legend->SetTextSize(0.03);
    legend->SetFillColor(kWhite);
    legend->SetTextAlign(12);
    //legend->SetHeader("Track Profiles:");

    // Draw the legend
    legend->Draw();

    if (savePDF) {
        TString pdfName = "TrackProfiles.pdf";
        fCanvas->SaveAs(pdfName);
        TString pdfName1 = "TrackProfiles.png";
        fCanvas->SaveAs(pdfName1);
    }
    fCanvas->SaveAs("TrackProfiles.C");

    return fCanvas;
}